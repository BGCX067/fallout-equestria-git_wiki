#summary Documentation and how-tos (Work in progress)

= Introduction =

This here documentation will introduce you to scripting with our game engine.
First thing to know is that our scripting language is AngelScript: it has a syntax similar to C, with garbage collecting features and links directly to the engine's native C++ API.

You can learn how to write code in angelscript reading this documentation:

http://www.angelcode.com/angelscript/sdk/docs/manual/doc_script.html

== Firt things first ==
=== What parts of the game use script ? ===
Quite a few of them. Every scripts of each category is regrouped in a directory in the 'scripts' folder.

Here's a list of things that can be scripted:

- Articial Intelligences: they run when your a character is prompted to do something, allows you to implement behaviors into NPCs.

- Buffs: they're used to implement effects on a character that settles over time. They can be linked with a visual effect and are exectued every once in a while until the effect wears out.

- Dialogs: when writing dialogs, you have the liberty of setting hooks to the character's speeches. They can determine if the player can use an answer, or what happens if that answer is given.

- Objects: the objects can have hooks define for when they're used in specific ways. This is, for example, where weapons effect are scripted.

- Quests: whenever a condition or objective is completed in a quest, an 'update' hook is called so that the script (if there is one) can modify the quest and pick different endings for it.

- Pipbuck: it is possible to write your own pipbuck application. The pipbuck itself has an API that allow application to display an interface or to interact with the game whenever they need to.

= Scripting Dialogs =
We'll first start by learning how to script dialog. We'll use it to introduce ourselves to the data engine's API.

        string HookInit()
        {
          return ("SpeechKey");
        }

Every dialog script starts with the HookInit function. The value it returned will be used to select the opening line of the dialog (pronounced by the NPC).
We'll see how we can use that to make a character introduce himself only when he hasn't been met before:

        string HookInit()
        {
          Data data_engine = level.GetDataEngine();
          Data have_talked = data_engine["dialogs"]["Sterling"]["happened"];

          if (have_talked.Nil())
          {
            have_talked = 1;
            return ("FristGreetings");
          }
          return ("RegularGreetings");
        }

What are we seeing here ?
In the first line, you're introduced to the level global variable. It sums up everything that happens outsite of the world map. We use it here to get an instance of the DataEngine.

The DataEngine stores the game variables. There are many information that the game engine make available to you through it (character inventories, factions, pipbuck data and so on).
You can also use it to store persistent variable (persistent meaning they will be saved with the game).

The DataEngine uses the Data type. It's a dynamic wrapper for a string based data tree: you can dynamically creating or accessing branches using the index operator.
We use this first to crete our own variable 'have_talked'. The condition then checks if this variable has already been set before: if not, we set it to '1' and return "FirstGreetings", which will be our character introducing himself to the player. If not, we will simply return "RegularGreetings", our character simply saying something of the like of "Hi".

---
Workd in progress

= Scripting Characters =

Work in progress