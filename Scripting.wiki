#summary Documentation and how-tos (Work in progress)

= Introduction =

This here documentation will introduce you to scripting with our game engine.

== Firt things first ==
=== How do I AngelScript ? ==
First thing to know is that our scripting language is AngelScript: it has a syntax similar to C, with garbage collecting features and links directly to the engine's native C++ API.

Here's a sample of what it looks like
{{{
int absolute(int parameter)
{
  int result;

  if (parameter < 0)
    result = -parameter;
  else
    return = parameter;
  return (parameter);
}
}}}

You can learn how to write code in angelscript reading this documentation:

http://www.angelcode.com/angelscript/sdk/docs/manual/doc_script.html

The scripting langage is however fairly easy to apprehand, moreover if you're already familiar with other scripting languages.
It's object oriented. Our script engine is based on hooks only, so you don't have to write your objects, but you'll deal with ours.

Unlike many script language, the variable are typed, and there also is a notion of references (the @ character you'll see in some variable declarations).
I will explain how to use the references whenever it is relevant. I believe everything else about the language is quite self-explanatory.

=== What parts of the game use script ? ===
Quite a few of them. Every scripts of each category is regrouped in a directory in the 'scripts' folder.

Here's a list of things that can be scripted:

- Articial Intelligences: they run when your a character is prompted to do something, allows you to implement behaviors into NPCs.

- Buffs: they're used to implement effects on a character that settles over time. They can be linked with a visual effect and are exectued every once in a while until the effect wears out.

- Dialogs: when writing dialogs, you have the liberty of setting hooks to the character's speeches. They can determine if the player can use an answer, or what happens if that answer is given.

- Objects: the objects can have hooks define for when they're used in specific ways. This is, for example, where weapons effect are scripted.

- Quests: whenever a condition or objective is completed in a quest, an 'update' hook is called so that the script (if there is one) can modify the quest and pick different endings for it.

- Pipbuck: it is possible to write your own pipbuck application. The pipbuck itself has an API that allow application to display an interface or to interact with the game whenever they need to.

= Scripting Dialogs =
== The data engine ==
We'll first start by learning how to script dialog. We'll use it to introduce ourselves to the data engine's API.

{{{
string HookInit()
{
  return ("SpeechKey");
}
}}}

Every dialog script starts with the HookInit function. The value it returned will be used to select the opening line of the dialog (pronounced by the NPC).
We'll see how we can use that to make a character introduce himself only when he hasn't been met before:

{{{
string HookInit()
{
  Data data_engine = level.GetDataEngine();
  Data have_talked = data_engine["dialogs"]["Sterling"]["happened"];

  if (have_talked.Nil())
  {
    have_talked = 1;
    return ("FristGreetings");
  }
  return ("RegularGreetings");
}
}}}

What are we seeing here ?
In the first line, you're introduced to the level global variable. It sums up everything that happens outsite of the world map. We use it here to get an instance of the DataEngine.

The DataEngine stores the game variables. There are many information that the game engine make available to you through it (character inventories, factions, pipbuck data and so on).
You can also use it to store persistent variable (persistent meaning they will be saved with the game).

The DataEngine uses the Data type. It's a dynamic wrapper for a string based data tree: you can dynamically create or access branches using the index operator.
We use this firstly to create our own variable 'have_talked'. The condition then checks if this variable has already been set before: if not, we set it to '1' and return "FirstGreetings", which will be our character introducing himself to the player. If not, we will simply return "RegularGreetings", our character simply saying something of the like of "Hi".

== Visibility hooks ==
The dialog tool from the Game Editor allows you to add hooks to answers.
The simpler of those hooks is the visibility hook: it is used to select which of the current context's answers the player can pick.

A visibility hook looks like this:

{{{
bool CanPlayerSayThis()
{
  Data data_enine = level.GetDataEngine();
  Data knows_about_something = data_engine["stuff"]["knows_about_something"];

  if (knows_about_something.Nil())
    return (false); // The player can't say this cause he doesn't know about something
  return (true); // The player knows about something and can say this
}
}}}

Again we use the same features from the data engine to figure out if the player can or not pick one of our answers. The value can then be set from elsewhere when some NPC's make a revelation to the player's.

== Answers hooks ==
The second type of hook that can be set to an answer is executed when the player picks it: it will override the "GoTo" context configured in the dialog editor: the return value of your hook will be used instead, allowing you to chose what the NPC will answer to the player's pick.

In this exemple, we'll introduce the Character and Statistics object to make a skill check allowing a special answer to the player if he has spent enough skill points on speech:

{{{
string AnswerToQuestion()
{
  Character@ player      = level.GetPlayer();
  Data       statistics  = player.GetStatistics();

  if (statistics["Skills"]["Speech"].AsInt() > 75)
  {
    Data     data_engine = level.GetDataEngine();

    data_engine["stuff"]["knows about something"] = 1;
    return ("SpecialAnswer");
  }
  return ("RegularAnswer");
}
}}}

Here, we get a reference to the player's character object to get a handle on his statistics.
There is several ways to interact with the statistic system, but when no logic is involved, you can simply access its datastore. You can check out a character sheet json file to get a look at the setup.

In the condition, we access the Speech skill variable and convert it as an Int with the AsInt method. AsString and AsFloat are also available.
If the skill is superior to 75, we will return the special answer, but not before informing the data engine that the player 'knows about something' now.

= Scripting Characters =

Work in progress